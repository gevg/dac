package dacsetdc

const (
	b       uint64 = 7           // bit width
	maxPlus uint64 = 1 << b      //
	mask    uint64 = maxPlus - 1 //
	numStr  int    = 6           // Number of streams
)

type stream struct { // Sneller zonder streams struct???
	bitArr []uint64 // bit-arrays
	chunks []byte   // chunk-arrays
	bitPtr uint32   // bitPtr points to the first empty position in bitArr
}

// Dacs ...
type Dacs struct {
 	streams [numStr]stream //
 	n       uint32         // number of elements
}

// New ... make n optional?
func New(n uint32) *Dacs { return &Dacs{n: n} }

// WriteUint64 ...
func (d *Dacs) WriteUint64(x uint64) int {
 	k := 1
 	d.streams[0].chunks = append(d.streams[0].chunks, byte(x&127|128))
 	x >>= 7
 	for x > 0 {
 		x--
 		d.streams[k].chunks = append(d.streams[k].chunks, byte(x&127))
 		x >>= 7
 		k++
 	}
 	return k
}

//  base = [...]uint64{0, 128, 128 + 128*128, 128 + 128*128 + 128*128*128, 128 + 128*128 + 128*128*128 + 128*128*128*128}
var base = [...]uint64{0, 128, 16512, 2113664, 270549120, 34630287488} // TODO: Extend list

// ReadUint64 ...
// func (d *Dacs) ReadUint64(i int) (x uint64) {
// 	k := len(buf) - 1
// 	y := uint64(buf[k])
// 	for y < 128 {
// 		x = x<<7 + y
// 		k--
// 		y = uint64(buf[k])
// 	}
// 	return base[len(buf)-1] + x<<7 + y - 128
// }
